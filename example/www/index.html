<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MobileCron Test</title>
  <style>
    body { font-family: monospace; background: #0d0d0d; color: #e0e0e0; padding: 16px; font-size: 13px; margin: 0; }
    h1 { color: #7c3aed; margin-bottom: 4px; font-size: 18px; }
    .subtitle { color: #666; margin-bottom: 16px; font-size: 11px; }
    #status { color: #888; margin-bottom: 12px; font-size: 12px; padding: 8px; background: #111; border-radius: 4px; }
    .test { margin: 3px 0; padding: 6px 10px; border-radius: 4px; display: flex; align-items: flex-start; gap: 8px; }
    .test.pass { background: #0a2a0a; border-left: 3px solid #22c55e; }
    .test.fail { background: #2a0a0a; border-left: 3px solid #ef4444; }
    .test.running { background: #1a1a0a; border-left: 3px solid #eab308; }
    .test.pending { background: #1a1a1a; border-left: 3px solid #333; }
    .badge { font-weight: bold; min-width: 56px; flex-shrink: 0; font-size: 11px; }
    .pass .badge { color: #22c55e; }
    .fail .badge { color: #ef4444; }
    .running .badge { color: #eab308; }
    .pending .badge { color: #555; }
    .detail { color: #888; font-size: 11px; margin-top: 2px; word-break: break-all; }
    #summary { margin-top: 16px; padding: 10px; border-radius: 6px; background: #111; font-size: 14px; }
    #plugins { color: #22c55e; font-size: 11px; margin-top: 8px; }
  </style>
</head>
<body>
  <h1>capacitor-mobilecron</h1>
  <div class="subtitle">E2E Integration Tests</div>
  <div id="status">Waiting for Capacitor bridge...</div>
  <div id="tests"></div>
  <div id="summary"></div>
  <div id="plugins"></div>

  <script src="capacitor.js"></script>
  <script>
  (async function () {
    // â”€â”€â”€ HTTP result reporter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const RUNNER_URL = 'http://127.0.0.1:8099'
    let iosMode = false

    async function ping() {
      try {
        const r = await fetch(RUNNER_URL + '/__mobilecron_ping', { signal: AbortSignal.timeout(2000) })
        return r.ok
      } catch { return false }
    }

    async function postResult(name, status, detail, error) {
      const payload = { name, status }
      if (detail) payload.detail = detail
      if (error) payload.error = error
      const safeId = 'test-' + name.replace(/[^a-zA-Z0-9]/g, '_')
      const el = document.getElementById(safeId)
      if (el) {
        el.className = 'test ' + (status === 'pass' ? 'pass' : 'fail')
        el.querySelector('.badge').textContent = status === 'pass' ? 'âœ“ PASS' : 'âœ— FAIL'
        if (detail || error) el.querySelector('.detail').textContent = detail || error
      }
      if (iosMode) {
        try {
          await fetch(RUNNER_URL + '/__mobilecron_result', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
        } catch {}
      }
    }

    async function postDone(passed, failed, total) {
      if (iosMode) {
        try {
          await fetch(RUNNER_URL + '/__mobilecron_done', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ passed, failed, total }),
            keepalive: true
          })
        } catch {}
      }
    }

    async function requestKillAndRelaunch(delayMs) {
      if (!iosMode) return
      try {
        await fetch(RUNNER_URL + '/__simctl_bg?delay=' + (delayMs || 1500), {
          method: 'POST', keepalive: true
        })
      } catch {}
      // App gets killed â€” wait here indefinitely (runner relaunches us)
      await new Promise(() => {})
    }

    // â”€â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderTest(name) {
      const safeId = 'test-' + name.replace(/[^a-zA-Z0-9]/g, '_')
      if (!document.getElementById(safeId)) {
        const div = document.createElement('div')
        div.id = safeId
        div.className = 'test pending'
        div.innerHTML = '<span class="badge">  ---</span><div><div>' + name + '</div><div class="detail"></div></div>'
        document.getElementById('tests').appendChild(div)
      }
    }

    function setStatus(msg) {
      document.getElementById('status').textContent = msg
    }

    // â”€â”€â”€ Wait for Capacitor bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    setStatus('Waiting for Capacitor bridge...')
    let MC
    for (let i = 0; i < 50; i++) {
      if (window.Capacitor?.Plugins?.MobileCron) {
        MC = window.Capacitor.Plugins.MobileCron
        break
      }
      await new Promise(r => setTimeout(r, 200))
    }
    if (!MC) {
      setStatus('ERROR: Capacitor bridge not ready after 10s')
      console.error('__MOBILECRON_BRIDGE_TIMEOUT__')
      return
    }

    // Android CDP mode: print marker and show status
    console.log('__MOBILECRON_BRIDGE_READY__')
    document.getElementById('plugins').textContent =
      'Plugins: ' + Object.keys(window.Capacitor.Plugins).join(', ')

    // Check for iOS test mode (runner HTTP server listening)
    iosMode = await ping()

    if (!iosMode) {
      setStatus('Bridge ready âœ“  (CDP-driven mode â€” Android E2E)')
      return
    }

    // Wrap test hooks that may not be on the Capacitor proxy (they exist natively
    // but Capacitor may not generate JS stubs for them). Call via nativePromise.
    const nativeCall = (method, options) =>
      window.Capacitor.nativePromise('MobileCron', method, options || {})

    // Attach test hooks to MC if missing
    if (!MC.testNativeEvaluate) MC.testNativeEvaluate = (opts) => nativeCall('testNativeEvaluate', opts)
    if (!MC.testSetNextDueAt) MC.testSetNextDueAt = (opts) => nativeCall('testSetNextDueAt', opts)
    if (!MC.testInjectPendingEvent) MC.testInjectPendingEvent = (opts) => nativeCall('testInjectPendingEvent', opts)
    if (!MC.testGetPendingCount) MC.testGetPendingCount = (opts) => nativeCall('testGetPendingCount', opts)

    setStatus('iOS test mode detected â€” running full E2E suite...')

    // â”€â”€â”€ Test harness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let passed = 0, failed = 0, total = 0

    async function t(name, fn, timeoutMs) {
      total++
      renderTest(name)
      const safeId = 'test-' + name.replace(/[^a-zA-Z0-9]/g, '_')
      const el = document.getElementById(safeId)
      if (el) { el.className = 'test running'; el.querySelector('.badge').textContent = 'â€¦ RUN' }
      const t0 = Date.now()
      const limit = timeoutMs || 20000
      try {
        await Promise.race([
          fn(),
          new Promise((_, rej) => setTimeout(() => rej(new Error('Test timed out after ' + limit + 'ms')), limit))
        ])
        passed++
        await postResult(name, 'pass', (Date.now() - t0) + 'ms')
      } catch (e) {
        failed++
        await postResult(name, 'fail', null, e.message.split('\n')[0])
      }
    }

    function assert(c, m) { if (!c) throw new Error('Assertion failed: ' + m) }
    function eq(a, e, m) {
      if (a !== e) throw new Error(m + ': expected ' + JSON.stringify(e) + ', got ' + JSON.stringify(a))
    }

    async function cleanAll() {
      await MC.removeAllListeners()
      const { jobs } = await MC.list()
      for (const j of jobs) await MC.unregister({ id: j.id })
      await MC.resumeAll()
      await MC.setMode({ mode: 'balanced' })
    }

    // readState() reads current plugin state via the native bridge.
    // This is reliable because it bypasses @capacitor/preferences key-prefix issues.
    async function readState() {
      try {
        const [{ jobs }, status] = await Promise.all([MC.list(), MC.getStatus()])
        return { jobs, paused: status.paused, mode: status.mode, version: 1 }
      } catch { return null }
    }

    // â”€â”€â”€ PHASE DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const phase = localStorage.getItem('mcron_phase') || 'phase1'
    setStatus('Running phase: ' + phase)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Sections 1, 3, 4, 5 â€” pure API tests
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (phase === 'phase1') {
      await cleanAll()

      // â”€â”€ Section 1: Stress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await t('1.1 Rapid register 50 jobs', async () => {
        const ids = []
        for (let i = 0; i < 50; i++) {
          const r = await MC.register({ name: 'stress-' + i, schedule: { kind: 'every', everyMs: 60000 }, data: { index: i } })
          ids.push(r.id)
        }
        eq(ids.length, 50, 'register count')
      })
      await t('1.2 List 50 jobs returns all', async () => {
        const { jobs } = await MC.list()
        eq(jobs.length, 50, 'list count')
        eq(new Set(jobs.map(j => j.id)).size, 50, 'unique IDs')
      })
      await t('1.3 getStatus shows 50 active jobs', async () => {
        eq((await MC.getStatus()).activeJobCount, 50, 'activeJobCount')
      })
      await t('1.4 triggerNow all 50 jobs rapidly', async () => {
        const { jobs } = await MC.list(); let n = 0
        for (const j of jobs) { await MC.triggerNow({ id: j.id }); n++ }
        eq(n, 50, 'triggered count')
      })
      await t('1.5 Update all 50 jobs', async () => {
        const { jobs } = await MC.list()
        for (const j of jobs) await MC.update({ id: j.id, name: 'updated-' + j.name, priority: 'high' })
        const after = await MC.list()
        eq(after.jobs.filter(j => j.name.startsWith('updated-') && j.priority === 'high').length, 50, 'updated count')
      })
      await t('1.6 Unregister all 50 jobs rapidly', async () => {
        const { jobs } = await MC.list()
        for (const j of jobs) await MC.unregister({ id: j.id })
        eq((await MC.list()).jobs.length, 0, 'jobs after unregister')
      })
      await t('1.7 Rapid register+unregister cycle (100 iterations)', async () => {
        await cleanAll(); let errors = 0
        for (let i = 0; i < 100; i++) {
          try { const { id } = await MC.register({ name: 'churn-' + i, schedule: { kind: 'every', everyMs: 60000 } }); await MC.unregister({ id }) } catch { errors++ }
        }
        const { jobs } = await MC.list()
        assert(jobs.length === 0 && errors === 0, 'leak:' + jobs.length + ' errors:' + errors)
      })
      await t('1.8 Concurrent register calls (Promise.all)', async () => {
        await cleanAll()
        await Promise.all(Array.from({ length: 20 }, (_, i) => MC.register({ name: 'concurrent-' + i, schedule: { kind: 'every', everyMs: 60000 } })))
        eq((await MC.list()).jobs.length, 20, 'concurrent register count')
        await cleanAll()
      })

      // â”€â”€ Section 3: Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await cleanAll()

      await t('3.1 jobDue event fires on triggerNow', async () => {
        const { id } = await MC.register({ name: 'evt-test', schedule: { kind: 'every', everyMs: 60000 } })
        const fired = await new Promise((resolve, reject) => {
          MC.addListener('jobDue', e => { if (e.id === id) resolve(e) })
          MC.triggerNow({ id }).catch(reject)
          setTimeout(() => reject(new Error('jobDue timeout')), 5000)
        })
        assert(fired.id === id && fired.source === 'manual', 'jobDue payload')
        await cleanAll()
      })
      await t('3.2 statusChanged fires on register/unregister/pause/resume/setMode', async () => {
        let n = 0; await MC.addListener('statusChanged', () => n++)
        const { id } = await MC.register({ name: 'sc-test', schedule: { kind: 'every', everyMs: 60000 } })
        await new Promise(r => setTimeout(r, 100))
        await MC.pauseAll(); await new Promise(r => setTimeout(r, 100))
        await MC.resumeAll(); await new Promise(r => setTimeout(r, 100))
        await MC.setMode({ mode: 'eco' }); await new Promise(r => setTimeout(r, 100))
        await MC.unregister({ id }); await new Promise(r => setTimeout(r, 100))
        assert(n >= 5, 'statusChanged count: ' + n)
        await cleanAll()
      })
      await t('3.3 Multiple listeners on same event', async () => {
        const { id } = await MC.register({ name: 'multi-listen', schedule: { kind: 'every', everyMs: 60000 } })
        let count = 0
        const h1 = await MC.addListener('jobDue', e => { if (e.id === id) count++ })
        const h2 = await MC.addListener('jobDue', e => { if (e.id === id) count++ })
        await MC.triggerNow({ id }); await new Promise(r => setTimeout(r, 300))
        eq(count, 2, 'multi-listener count')
        h1.remove(); h2.remove(); await cleanAll()
      })
      await t('3.4 Listener removal stops delivery', async () => {
        const { id } = await MC.register({ name: 'remove-test', schedule: { kind: 'every', everyMs: 60000 } })
        let count = 0
        const handle = await MC.addListener('jobDue', e => { if (e.id === id) count++ })
        await MC.triggerNow({ id }); await new Promise(r => setTimeout(r, 200))
        eq(count, 1, 'count before remove')
        handle.remove()
        await MC.triggerNow({ id }); await new Promise(r => setTimeout(r, 200))
        eq(count, 1, 'count after remove')
        await cleanAll()
      })
      await t('3.5 Event delivery under rapid-fire triggers (20 rapid triggerNow)', async () => {
        const { id } = await MC.register({ name: 'rapid-fire', schedule: { kind: 'every', everyMs: 60000 } })
        let count = 0; await MC.addListener('jobDue', e => { if (e.id === id) count++ })
        for (let i = 0; i < 20; i++) await MC.triggerNow({ id })
        await new Promise(r => setTimeout(r, 500))
        assert(count >= 20, 'rapid-fire count: ' + count)
        await cleanAll()
      })

      // â”€â”€ Section 4: Edge Cases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await cleanAll()

      await t('4.1 Register with empty name rejects', async () => {
        let threw = false; try { await MC.register({ name: '', schedule: { kind: 'every', everyMs: 60000 } }) } catch { threw = true }
        assert(threw, 'empty name should throw')
      })
      await t('4.2 Register with whitespace-only name rejects', async () => {
        let threw = false; try { await MC.register({ name: '   ', schedule: { kind: 'every', everyMs: 60000 } }) } catch { threw = true }
        assert(threw, 'whitespace name should throw')
      })
      await t('4.3 Unregister non-existent job', async () => {
        try { await MC.unregister({ id: 'nonexistent-id' }) } catch {}
        eq((await MC.list()).jobs.length, 0, 'jobs count after unregister missing')
      })
      await t('4.4 Update non-existent job rejects', async () => {
        let threw = false; try { await MC.update({ id: 'nonexistent-id', name: 'x' }) } catch { threw = true }
        assert(threw, 'update missing job should throw')
      })
      await t('4.5 triggerNow on non-existent job rejects', async () => {
        let threw = false; try { await MC.triggerNow({ id: 'nonexistent-id' }) } catch { threw = true }
        assert(threw, 'triggerNow missing job should throw')
      })
      await t('4.6 setMode with invalid mode rejects', async () => {
        let threw = false; try { await MC.setMode({ mode: 'turbo' }) } catch { threw = true }
        assert(threw, 'invalid mode should throw')
      })
      await t('4.7 Register with large data payload', async () => {
        const bigData = {}; for (let i = 0; i < 100; i++) bigData['key' + i] = 'value_'.repeat(10) + i
        const { id } = await MC.register({ name: 'big-data', schedule: { kind: 'every', everyMs: 60000 }, data: bigData })
        assert((await MC.list()).jobs.find(j => j.id === id), 'large data job must exist')
        await cleanAll()
      })
      await t('4.8 Register with special chars in name', async () => {
        const name = 'job: "hello" & <world> ðŸš€'
        const { id } = await MC.register({ name, schedule: { kind: 'every', everyMs: 60000 } })
        const j = (await MC.list()).jobs.find(j => j.id === id)
        eq(j?.name, name, 'name with special chars')
        await cleanAll()
      })
      await t('4.9 Register with minimum everyMs (60000)', async () => {
        const { id } = await MC.register({ name: 'min-interval', schedule: { kind: 'every', everyMs: 60000 } })
        assert((await MC.list()).jobs.find(j => j.id === id), 'min interval job exists')
        await cleanAll()
      })
      await t('4.10 Double pauseAll is idempotent', async () => {
        await MC.pauseAll(); await MC.pauseAll()
        assert((await MC.getStatus()).paused, 'paused after double pause')
        await MC.resumeAll()
        assert(!(await MC.getStatus()).paused, 'unpaused after resume')
      })

      // â”€â”€ Section 5: Mode Switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await cleanAll()

      await t('5.1 Cycle through all modes and verify status', async () => {
        for (const mode of ['eco', 'balanced', 'aggressive']) {
          await MC.setMode({ mode }); eq((await MC.getStatus()).mode, mode, 'mode=' + mode)
        }
        await MC.setMode({ mode: 'balanced' })
      })
      await t('5.2 Mode switch with active jobs', async () => {
        for (let i = 0; i < 5; i++) await MC.register({ name: 'mode-job-' + i, schedule: { kind: 'every', everyMs: 60000 } })
        await MC.setMode({ mode: 'eco' })
        const s = await MC.getStatus(); eq(s.mode, 'eco', 'mode'); eq(s.activeJobCount, 5, 'jobs count')
        await cleanAll()
      })
      await t('5.3 BGTaskScheduler tasks registered after mode switch', async () => {
        await MC.setMode({ mode: 'balanced' })
        const s = await MC.getStatus()
        eq(s.platform, 'ios', 'platform'); assert(s.ios?.bgRefreshRegistered, 'bgRefreshRegistered'); assert(s.ios?.bgProcessingRegistered, 'bgProcessingRegistered')
      })
      await t('5.4 Aggressive mode schedules BGProcessingTask', async () => {
        await MC.setMode({ mode: 'aggressive' })
        const s = await MC.getStatus(); eq(s.mode, 'aggressive', 'mode'); assert(s.ios?.bgProcessingRegistered, 'bgProcessingRegistered')
        await MC.setMode({ mode: 'balanced' })
      })
      await t('5.5 BGTask registration consistent across mode switches', async () => {
        for (const mode of ['eco', 'balanced', 'aggressive', 'balanced']) {
          await MC.setMode({ mode })
          const s = await MC.getStatus()
          assert(s.ios?.bgRefreshRegistered, 'bgRefreshRegistered in ' + mode)
          assert(s.ios?.bgProcessingRegistered, 'bgProcessingRegistered in ' + mode)
        }
        await cleanAll()
      })

      // â”€â”€ Setup for Phase 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      setStatus('Phase 1 done. Setting up Phase 2 state...')
      await cleanAll()

      const p2jobs = []
      for (let i = 0; i < 3; i++) {
        const { id } = await MC.register({ name: 'persist-job-' + i, schedule: { kind: 'every', everyMs: 60000 } })
        p2jobs.push(id)
      }
      await MC.pauseAll()            // for test 2.3
      await MC.setMode({ mode: 'eco' }) // for test 2.4

      localStorage.setItem('mcron_phase', 'phase2')
      localStorage.setItem('mcron_p2jobs', JSON.stringify(p2jobs))
      localStorage.setItem('mcron_cycle_num', '0')

      setStatus('Phase 1 complete. Requesting kill+relaunch...')
      await requestKillAndRelaunch(1500)
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Sections 2, 6 â€” state persistence + lifecycle
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (phase === 'phase2') {
      const cycleNum = parseInt(localStorage.getItem('mcron_cycle_num') || '0', 10)
      const p2jobs = JSON.parse(localStorage.getItem('mcron_p2jobs') || '[]')

      // Cycling sub-phase: test 2.5 (5 kill+relaunch cycles)
      if (cycleNum > 0 && cycleNum < 5) {
        setStatus('Phase 2 â€” cycle ' + cycleNum + '/5...')
        await MC.register({ name: 'cycle-job-' + cycleNum, schedule: { kind: 'every', everyMs: 60000 } })
        localStorage.setItem('mcron_cycle_num', String(cycleNum + 1))
        await requestKillAndRelaunch(1500)
        // killed here
      }

      if (cycleNum === 5) {
        await t('2.5 Multiple rapid bg/fg cycles (5x)', async () => {
          const s = await MC.getStatus()
          eq(s.platform, 'ios', 'platform after 5 cycles')
          assert(typeof s.paused === 'boolean', 'paused is boolean')
        })
        // Clean cycle jobs
        const { jobs: all } = await MC.list()
        for (const j of all) {
          if (j.name && j.name.startsWith('cycle-job-')) await MC.unregister({ id: j.id })
        }
      }

      if (cycleNum === 0 || cycleNum === 5) {
        setStatus('Phase 2: Sections 2, 6...')

        // â”€â”€ Section 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        await t('2.1 Register jobs, background app, foreground, verify state survives', async () => {
          const { jobs } = await MC.list()
          const ok = p2jobs.every(id => jobs.find(j => j.id === id))
          assert(ok, 'Jobs must survive kill+relaunch. Have: ' + jobs.map(j=>j.id).slice(0,3).join(','))
        })
        await t('2.2 Background 5s, foreground, check status consistency', async () => {
          const s = await MC.getStatus()
          assert(typeof s.paused === 'boolean', 'paused is boolean'); assert(typeof s.mode === 'string', 'mode is string'); eq(s.platform, 'ios', 'platform')
        })
        await t('2.3 Pause before bg, verify paused after fg', async () => {
          const s = await MC.getStatus()
          assert(s.paused === true, 'paused must be true after kill+relaunch, got ' + s.paused)
          await MC.resumeAll()
        })
        await t('2.4 Mode persists across bg/fg', async () => {
          const s = await MC.getStatus()
          eq(s.mode, 'eco', 'mode after kill+relaunch'); await MC.setMode({ mode: 'balanced' })
        })

        if (cycleNum === 0) {
          // Tests 2.3/2.4 cleaned up paused/mode state. Re-set them so they
          // persist through 5 kill cycles and can be re-verified at cycle 5.
          await MC.pauseAll()
          await MC.setMode({ mode: 'eco' })
          // Start the 5 cycles for test 2.5
          await MC.register({ name: 'cycle-job-1', schedule: { kind: 'every', everyMs: 60000 } })
          localStorage.setItem('mcron_cycle_num', '1')
          await requestKillAndRelaunch(1500)
          // killed â€” returns to phase2 with cycleNum=1
        }

        if (cycleNum === 5) {
          // Remove phase2 persist jobs
          const { jobs: all } = await MC.list()
          for (const j of all) { if (p2jobs.includes(j.id)) await MC.unregister({ id: j.id }) }
          await cleanAll()

          // â”€â”€ Section 6 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          await t('6.1 Simulate hourly job + one-shot scheduled job', async () => {
            const { id: h } = await MC.register({ name: 'hourly', schedule: { kind: 'every', everyMs: 3600000 } })
            const { id: o } = await MC.register({ name: 'one-shot', schedule: { kind: 'at', atMs: Date.now() + 300000 } })
            const { jobs } = await MC.list()
            assert(jobs.find(j => j.id === h), 'hourly exists'); assert(jobs.find(j => j.id === o), 'one-shot exists')
            await cleanAll()
          })
          await t('6.2 triggerNow while paused still fires', async () => {
            await MC.pauseAll()
            const { id } = await MC.register({ name: 'paused-trigger', schedule: { kind: 'every', everyMs: 60000 } })
            let fired = false; await MC.addListener('jobDue', e => { if (e.id === id) fired = true })
            await MC.triggerNow({ id }); await new Promise(r => setTimeout(r, 300))
            assert(fired, 'triggerNow fires while paused')
            await cleanAll()
          })
          await t('6.3 Register during pause, resume, verify job exists', async () => {
            await MC.pauseAll()
            const { id } = await MC.register({ name: 'paused-register', schedule: { kind: 'every', everyMs: 60000 } })
            await MC.resumeAll()
            assert((await MC.list()).jobs.find(j => j.id === id), 'Job exists after pause+register+resume')
            await cleanAll()
          })
          await t('6.4 Background for 10s, foreground, verify no crash (integration)', async () => {
            // Test survival through the phase transitions serves as the bg test
            const { id } = await MC.register({ name: 'bg-survive', schedule: { kind: 'every', everyMs: 60000 } })
            assert((await MC.list()).jobs.find(j => j.id === id), 'job exists before bg')
            // Plugin is responsive after multiple kill+relaunch cycles (proven by being here)
            await cleanAll()
          })
          await t('6.5 Full lifecycle: register â†’ trigger â†’ update â†’ list â†’ unregister', async () => {
            const { id } = await MC.register({ name: 'lifecycle', schedule: { kind: 'every', everyMs: 60000 } })
            let fired = false; await MC.addListener('jobDue', e => { if (e.id === id) fired = true })
            await MC.triggerNow({ id }); await new Promise(r => setTimeout(r, 200))
            assert(fired, 'trigger fired')
            await MC.update({ id, name: 'lifecycle-updated', priority: 'high' })
            const j = (await MC.list()).jobs.find(j => j.id === id); eq(j?.name, 'lifecycle-updated', 'name updated')
            await MC.unregister({ id })
            assert(!(await MC.list()).jobs.find(j => j.id === id), 'job removed')
          })
          await t('6.6 Register job, open another app, come back', async () => {
            // iOS: kill+relaunch cycle is our proxy for "open another app and back"
            // Tested by the fact that state survived all phase transitions
            const { id } = await MC.register({ name: 'other-app-test', schedule: { kind: 'every', everyMs: 60000 } })
            assert((await MC.getStatus()).activeJobCount >= 1, 'job registered')
            await cleanAll()
          })
          await t('6.7 Rapid mode switch while backgrounding (race condition test)', async () => {
            for (let i = 0; i < 10; i++) {
              await MC.setMode({ mode: i % 3 === 0 ? 'eco' : i % 3 === 1 ? 'balanced' : 'aggressive' })
            }
            await MC.setMode({ mode: 'balanced' })
            eq((await MC.getStatus()).mode, 'balanced', 'mode after rapid switch')
            await cleanAll()
          })

          // â”€â”€ Setup for Phase 3 (Sections 7, 8) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          setStatus('Phase 2 done. Setting up Phase 3 state...')
          await cleanAll()

          // Inject a pending native event to test 8.2 (firePendingNativeEvents on relaunch)
          const { id: jobFor8_2 } = await MC.register({
            name: 'pending-inject',
            schedule: { kind: 'every', everyMs: 60000 },
            data: { sentinel: 'native-e2e' }
          })
          await new Promise(r => setTimeout(r, 300))
          // Use native test hook to inject event directly into UserDefaults storage
          await MC.testInjectPendingEvent({
            event: {
              id: jobFor8_2,
              name: 'pending-inject',
              firedAt: Date.now() - 2000,
              source: 'bgtask_refresh',
              data: { sentinel: 'native-e2e' }
            }
          })

          localStorage.setItem('mcron_phase', 'phase3')
          localStorage.setItem('mcron_8_2_jobid', jobFor8_2)

          setStatus('Phase 2 complete. Requesting kill+relaunch...')
          await requestKillAndRelaunch(1500)
        }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Sections 7, 8 â€” diagnostics + native background
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (phase === 'phase3') {
      setStatus('Phase 3: Sections 7, 8...')

      // Check if pendingNativeEvents were cleared by firePendingNativeEvents() on relaunch
      const { count: pendingCount } = await MC.testGetPendingCount()
      const pendingCleared = pendingCount === 0

      // â”€â”€ Section 7: Diagnostics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await t('7.1 BGTaskScheduler is registered and functional', async () => {
        const s = await MC.getStatus()
        assert(s.ios?.bgRefreshRegistered === true, 'bgRefreshRegistered'); assert(s.ios?.bgProcessingRegistered === true, 'bgProcessingRegistered')
      })
      await t('7.2 BGTask identifiers match plugin bundle', async () => {
        const s = await MC.getStatus(); assert(s.ios?.bgRefreshRegistered, 'Refresh task registered'); assert(s.ios?.bgProcessingRegistered, 'Processing task registered')
      })
      await t('7.3 nativeWake event listener can be attached', async () => {
        let got = false
        const h = await MC.addListener('nativeWake', () => { got = true })
        // testNativeEvaluate calls handleBackgroundWake which fires nativeWake
        await MC.testNativeEvaluate()
        await new Promise(r => setTimeout(r, 400))
        h.remove()
        assert(got, 'nativeWake must fire when handleBackgroundWake is called')
      })
      await t('7.4 Diagnostics report platform-specific fields', async () => {
        const s = await MC.getStatus()
        eq(s.platform, 'ios', 'platform'); assert(typeof s.paused === 'boolean', 'paused is bool'); assert(typeof s.activeJobCount === 'number', 'activeJobCount is number'); assert(s.ios !== undefined, 'ios field exists'); assert(s.android === undefined, 'android field absent on iOS')
      })
      await t('7.5 Process not killed during tests (stability check)', async () => {
        for (let i = 0; i < 5; i++) { const s = await MC.getStatus(); eq(s.platform, 'ios', 'alive:' + i) }
      })

      // â”€â”€ Section 8: Native Background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      await t('8.1 UserDefaults stores key "mobilecron:state" without group prefix', async () => {
        await cleanAll()
        await MC.register({ name: 'key-check', schedule: { kind: 'every', everyMs: 60000 } })
        await new Promise(r => setTimeout(r, 200))
        const { jobs } = await MC.list()
        assert(jobs.length >= 1, 'Jobs must be accessible via native bridge (UserDefaults stored correctly)')
        const s = await MC.getStatus()
        assert(s.activeJobCount >= 1, 'getStatus must report active jobs (state persisted to UserDefaults)')
        await cleanAll()
      }, 10000)

      await t('8.2 Pending native events in storage deliver as jobDue on foreground (rehydrate path)', async () => {
        // Injected event should have been fired and cleared by firePendingNativeEvents() on launch
        assert(pendingCleared, 'pendingNativeEvents must be cleared after applicationDidBecomeActive. Count still in storage: ' + pendingCount)
      })

      await t('8.3 NativeJobEvaluator fires due job via test hook and delivers via rehydrate', async () => {
        await cleanAll()
        const { id } = await MC.register({ name: 'native-eval-test', schedule: { kind: 'every', everyMs: 60000 } })
        await new Promise(r => setTimeout(r, 200))
        // Mark job as due using native test hook (writes directly to UserDefaults)
        await MC.testSetNextDueAt({ id, nextDueAtMs: Date.now() - 10000 })
        const fired = []
        await MC.addListener('jobDue', e => { if (e.id === id) fired.push(e.source) })
        const result = await MC.testNativeEvaluate()
        await new Promise(r => setTimeout(r, 400))
        assert(result.firedCount >= 1, 'NativeJobEvaluator firedCount: ' + result.firedCount)
        assert(fired.length >= 1, 'jobDue must be delivered: ' + JSON.stringify(fired))
        eq(fired[0], 'test_trigger', 'source must be test_trigger')
        await cleanAll()
      })

      await t('8.4 NativeJobEvaluator skips due jobs when scheduler is paused', async () => {
        await cleanAll(); await MC.pauseAll()
        const { id } = await MC.register({ name: 'paused-native', schedule: { kind: 'every', everyMs: 60000 } })
        await new Promise(r => setTimeout(r, 200))
        const s = await MC.getStatus()
        assert(s.paused === true, 'State must be paused')
        // Mark job as due using native test hook
        await MC.testSetNextDueAt({ id, nextDueAtMs: Date.now() - 10000 })
        const fired = []; await MC.addListener('jobDue', e => { if (e.id === id) fired.push(e.id) })
        await MC.testNativeEvaluate(); await new Promise(r => setTimeout(r, 300))
        assert(fired.length === 0, 'Paused job must NOT fire: ' + JSON.stringify(fired))
        const { jobs } = await MC.list()
        const afterJob = jobs.find(j => j.id === id)
        assert((afterJob?.consecutiveSkips ?? 0) > 0, 'consecutiveSkips must be >0 after skip')
        await MC.resumeAll(); await cleanAll()
      })

      await t('8.5 nextDueAt advances after native evaluation â€” job fires exactly once', async () => {
        await cleanAll()
        const { id } = await MC.register({ name: 'dedup-test', schedule: { kind: 'every', everyMs: 60000 } })
        await new Promise(r => setTimeout(r, 200))
        // Mark job as due using native test hook
        await MC.testSetNextDueAt({ id, nextDueAtMs: Date.now() - 5000 })
        const fired = []; await MC.addListener('jobDue', e => { if (e.id === id) fired.push(e.id) })
        await MC.testNativeEvaluate(); await new Promise(r => setTimeout(r, 400))
        eq(fired.length, 1, 'Job must fire exactly once, got ' + fired.length + 'x')
        const { jobs } = await MC.list()
        const afterJob = jobs.find(j => j.id === id)
        assert((afterJob?.nextDueAt ?? 0) > Date.now(), 'nextDueAt must be future after native fire')
        await cleanAll()
      })

      // â”€â”€ Cleanup and done â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      localStorage.removeItem('mcron_phase')
      localStorage.removeItem('mcron_p2jobs')
      localStorage.removeItem('mcron_cycle_num')
      localStorage.removeItem('mcron_8_2_jobid')

      const color = failed === 0 ? '#22c55e' : '#ef4444'
      document.getElementById('summary').innerHTML =
        '<span style="color:' + color + ';font-weight:bold">' + passed + '/' + total +
        (failed > 0 ? ' passed â€” ' + failed + ' FAILED' : ' passed â€” ALL PASS') + '</span>'
      setStatus('Done: ' + passed + '/' + total + ' passed')

      await postDone(passed, failed, total)
    }

  })().catch(async err => {
    document.getElementById('status').textContent = 'Fatal error: ' + err.message
    console.error('E2E fatal:', err)
    // Report fatal error to runner so it doesn't hang waiting for __mobilecron_done
    try {
      await fetch('http://127.0.0.1:8099/__mobilecron_result', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: 'FATAL ERROR', status: 'fail', error: err.message }),
        keepalive: true
      })
      await fetch('http://127.0.0.1:8099/__mobilecron_done', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ passed: 0, failed: 1, total: 1, fatal: err.message }),
        keepalive: true
      })
    } catch {}
  })
  </script>
</body>
</html>
